# Segment-Tree
[【学习笔记】详解线段树(浅显易懂,匠心之作,图文并茂)-CSDN博客](https://blog.csdn.net/weq2011/article/details/128791426)

[ST算法解决RMQ问题详解(图文并茂,保证看懂)-CSDN博客](https://blog.csdn.net/weq2011/article/details/128682500)

##### 线段树 

先递归建树

```c
void bui(int id,int l,int r)//创建线段树,id表示存储下标,区间[L,r]
{
  if(l == r)//左端点等于右端点，即为叶子节点(区间长度为1)，直接赋值即可
  {
    tr[id] = a[l];
    return ;
  }
// 否则将当前区间中间拆开成两个区间
  int mid = (l + r) / 2;//mid则为中间点，左儿子的结点区间为[l,mid],右儿子的结点区间为[mid + 1,r]
  bui(id * 2,l,mid); //递归构造左儿子结点
  bui(id * 2 + 1,mid + 1,r); //递归构造右儿子结点
// 左右两个区间计算完成以后
// 合并到当前区间
  tr[id] = max(tr[id * 2],tr[id * 2 + 1]);//更新父节点
}
```

然后进行区间查询

```c
//id 表示树节点编号，l r 表示这个节点所对应的区间
//x y表示查询的区间
int find(int id,int l,int r,int x,int y)
{
  //需要查询的区间[x,y]将当前区间[l,r]包含的时候
  if(x <= l && r <= y) return tr[id];
  int mid = (l + r) / 2,ans = -INT_MAX;
   // 如果需要查询左半区间
  if(x <= mid) ans = max(ans,find(id * 2,l,mid,x,y));   
  // 如果需要查询右半区间
  if(y > mid) ans = max(ans,find(id * 2 + 1,mid + 1,r,x,y));
  return ans;
}
```

然后是单点更新

```c
// id 表示树节点编号，l r 表示这个节点所对应的区间
// 将 a[x] 修改为 v
// 线段树单点更新
void gexi(int id, int l, int r, int x, int v)
{
// 找到长度为 1 的区间才返回
  if (l == r)
  {
    tr[id] = v;
    return;
  }
//否则找到 x 在左区间或者右区间去更新
  int mid = (l + r) / 2;
  if (x <= mid) gexi(id * 2, l, mid, x, v);// 需要修改的值在左区间
  else gexi(id * 2 + 1, mid + 1, r, x, v);// 需要修改的值在右区间
  tr[id] = max(tr[id * 2], tr[id * 2 + 1]);
}
```



# 例题P1816 忠诚

## 题目描述

老管家是一个聪明能干的人。他为财主工作了整整 $10$ 年。财主为了让自已账目更加清楚，要求管家每天记  $k$ 次账。由于管家聪明能干，因而管家总是让财主十分满意。

但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚。他把每次的账目按 $1, 2, 3, \ldots$ 编号，然后不定时地问管家这样的问题：在 $a$ 到 $b$ 号账中最少的一笔是多少？

为了让管家没时间作假，他总是一次问多个问题。

## 输入格式

第一行输入两个数 $m, n$，表示有 $m$ 笔账和 $n$ 个问题。  
第二行输入 $m$ 个数，分别表示账目的钱数。  
接下来 $n$ 行分别输入 $n$ 个问题，每行 $2$ 个数字，分别表示开始的账目编号 $a$ 和结束的账目编号 $b$。

## 输出格式

第一行输出每个问题的答案，每个答案中间以一个空格分隔。

## 输入输出样例 #1

### 输入 #1

```
10 3
1 2 3 4 5 6 7 8 9 10
2 7
3 9
1 10
```

### 输出 #1

```
2 3 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \leq m \leq 10^5$，$1 \leq n \leq 10^5$。
